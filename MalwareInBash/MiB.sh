# MalwareInBash (MiB)
# Marcus Botacin - 2017
# Bash utils for malware static analysis

# Check if a given binary is a PE file
is_pe()
{
	# check if binary path was supplied
	[ $# -eq 0 ] && echo "False" && return 1
	# query file info
	# check for PE32 signature
	# it covers both PE32 and PE32+ matches
	file $1 | grep "PE32" >/dev/null;
	# if grep didn't found that (returned 1), False
	[ $? -eq 1 ] && echo "False" && return 1;
	# otherwise, true
	echo "True"
}

# check if a given binary is PE, and not PE32
is_pe32()
{
	# check args
	[ $# -eq 0 ] && echo "False" && return 1
	# it applies only for PE files
	[ `is_pe $1` == "False" ] && echo "False" && return 1;
	# grep for PE32+
	file $1 | cut -d' ' -f2 | grep "PE32+" >/dev/null;
	# if it was found, it is not PE32
	[ $? -eq 0 ] && echo "False" && return 1;
	# if it was not found, it is PE32 
	echo "True"
}

# check if a given binary is PE32+ (x64)
is_pe64()
{
	# args
	[ $# -eq 0 ] && echo "False" && return 1
	# check PE32+ sign
	file $1 | cut -d' ' -f2 | grep "PE32+" >/dev/null;
	# not found, False
	[ $? -eq 1 ] && echo "False" && return 1;
	# if grep suceeded, True
	echo "True"
}

# check if a given file has DLL characteristics
is_dll()
{
	# args
	[ $# -eq 0 ] && echo "False" && return 1;
	# check if it is PE
	# A DLL is also a PE file
	[ `is_pe $1` == "False" ] && echo "False" && return 1;
	# case it is a candidate
	# call Python auxiliary tool
	python $UTILS_PATH/is_dll.py $1;
}

# get file extension
get_ext()
{
	# args
	[ $# -eq 0 ] && echo "False" && return 1;
	# reverse, cut on the last delimiter (.) and reverse again
	[[ $1 == *"."* ]] && echo $1 | rev | cut -d'.' -f1 | rev && return 0;
	# case no extension was found
	echo "False" && return 1;
}

# check if a binary is .Net compiled
is_dotnet()
{
	# args
	[ $# -eq 0 ] && echo "False" && return 1
	# file information
	# Check for .Net signature
	file $1 | cut -d' ' -f7 | grep ".Net" >/dev/null;
	# case not found, False
	[ $? -eq 1 ] && echo "False" && return 1;
	# Otherwise, True
	echo "True"
}

# Retrieve section names from binaries
get_section()
{
	# check args
	[ $# -eq 0 ] && echo "False" && return 1
	# get section and parse
	# ignore the first 5 lines -- NR>5 -- (objdump header)
	# consider only the lines starting with a number (address) -- ([0-9])
	# delimiter on the name field (f4)
	objdump -h $1 | awk 'NR > 5' | grep -e "[0-9]" | cut -d' ' -f4;
}

# print all PE files on a dir
print_is_pe()
{
	# iterate on the dir
	for i in `ls`; do 
	if [ `is_pe $i` == "True" ]; then 
		# case True
		echo $i;
	fi;
	done;
}

# the same for PE32
print_is_pe32()
{
	for i in `ls`; do 
	if [ `is_pe32 $i` == "True" ]; then 
		echo $i;
	fi;
	done;
}

# The same for PE64
print_is_pe64()
{
	for i in `ls`; do 
	if [ `is_pe64 $i` == "True" ]; then 
		echo $i;
	fi;
	done;
}

# the same for DLL
print_is_dll()
{
	for i in `ls`; do 
	# Passing the absolute path to the python script
	if [ `is_dll $PWD/$i` == "True" ]; then 
		echo $i;
	fi;
	done;
}

# the same for .Net
print_is_dotnet()
{
	for i in `ls`; do 
	if [ `is_dotnet $i` == "True" ]; then 
		echo $i;
	fi;
	done;
}

# Install Routine
# export the var which stores the python script path
DIR=`dirname ${BASH_SOURCE[0]}`
export UTILS_PATH=$DIR/utils
# welcome message
echo "Malware in Bash"
