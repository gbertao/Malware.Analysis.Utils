#!/usr/bin/env python
# Allow shell without calling py directly

# Marcus Botacin
# UNICAMP 2017
# A tool for scheduling honeypot-collected samples for analysis
# Implemented on Linux using Inotify

# Import Block

import os				# OS utils 	- file-system properties
import sys				# args		- parameters
import threading as t			# thread	- locks por multithread operation
import pyinotify			# FS wrapper	- notifications for uploaded files
from collections import deque		# data struct	- ordered execution of uploaded files

# System Configuration

# define the number of threads
global n_threads
n_threads = 3

# List Lock
# it provides consistency on parallel operation
global list_lock
list_lock = t.Lock()

# Paths
# Malware Source Folder (Binary Repository)
global srcfolder
srcfolder="/tmp/malware"
# Malware Destination Folder (Log Repository)
global dstfolder
dstfolder="/tmp/analysis"

# Event List
# the list itself
# deque for ordered use
# push new data on one side,
# pop old data from the other
global event_list
event_list = deque([])

# condition variable
# to wait on the list lock
global cv
cv = t.Condition(list_lock)

# Inotify variables

# recursive mode
global inotify_rec_mode
inotify_rec_mode=True
# auto mode
global inotify_auto_add
inotify_auto_add=True
# recursive flags
global inotify_flags
inotify_flags=pyinotify.IN_CLOSE_WRITE|pyinotify.IN_MOVED_TO|pyinotify.IN_CREATE|pyinotify.IN_CLOSE_NOWRITE


# ********************
# * Inotify Callback *
# ********************

# This is the callback invoked for registered events
# Pyinotify is a wrapper for Linux Inotify callback

class callback(pyinotify.ProcessEvent):
	# We have to define distinct events handling
	# when using rsync, it can raises more than one at time
	
	# handler for file close event on filesystem
	# assumes close_write happens only for files, not for directories
	def process_IN_CLOSE_WRITE(self,evt):
		# A lot of debug prints
		if(__debug__):
                    print("[INOTIFY] IN_CLOSE_WRITE called. PATH: %s NAME: %s PATHNAME: %s" % (evt.path,evt.name,evt.pathname))
		#Just Add to List
		cv.acquire()
		event_list.append(evt)
		# wake up threads
		cv.notify()
		cv.release()
	# handler for "move" on filesystem
	# assumes happens only for files
	def process_IN_MOVED_TO(self,evt):
		if(__debug__):
                    print("[INOTIFY] IN_MOVED_TO called. PATH: %s NAME: %s PATHNAME: %s" % (evt.path,evt.name,evt.pathname))
		#Just Add to List
		cv.acquire()
		event_list.append(evt)
		# wake up threads
		cv.notify()
		cv.release()

	# handler for create event on filesystem
	# assume it happens for directories and files
	def process_IN_CREATE(self,evt):
		# if the content is a directory
		if (os.path.isdir(evt.pathname) is True):
			# no action is taken
			# let the recursive mode to monitor it
			if(__debug__):
                            print("[INOTIFY] IN_CREATE called. DIRECTORY created")
		else:
			# is a file
			if(__debug__):
                            print("[INOTIFY] IN_CREATE called. PATH: %s NAME: %s PATHNAME: %s" % (evt.path,evt.name,evt.pathname))
			# add on list
			cv.acquire()
			event_list.append(evt)
			# wake up threads
			cv.notify()
			cv.release()

# Analyzer thread

class AnalyzerThread(t.Thread):

        def run(self):
                # Thread id is the number given in the constructor thread name
                thread_id= str(self.getName()).split('-')[1]
                if(__debug__):
                    print("Starting thread "+thread_id) #debug print

                while True: #it will run forever
                                
                        #WAKE UP when having data
                        #lock and get data
                        cv.acquire()
                        # if list is empty
                        while not event_list:
                                cv.wait() #wait sleeping

                        #
                        #       wake up         < - 
                        #          |              |
                        #       sleep if empty  -> 
                        #          |    
                        #       run
                        #


                        # get data
                        evt = event_list.popleft() #the last one

                        if(__debug__):
                            print("[Thread %s]: %s popped for analysis " % (thread_id,evt.name)) #debug print

                        # put the analysis code HERE

                        # let next thread work
                        cv.release()


# Main

def main():

	#Create Threads
	
	# Create and initialize each one of N threads
	for i in range(0,n_threads):
		mt = AnalyzerThread() # Create
		mt.start() # start

	# Inotify Setup
	handler = callback()
	wm = pyinotify.WatchManager()
	notifier = pyinotify.Notifier(wm,handler)
	# inotify events
	# global vars set operation modes
	wdd = wm.add_watch(srcfolder,inotify_flags,rec=inotify_rec_mode,auto_add=inotify_auto_add)
	# remain monitoring
	notifier.loop()


# HELP

def help():
	print("No lineargs supported. Only hardcoded data")
	print("Call python with -O to remove debug prints")

# Entry Point

# Check who is calling
# By now, only direct calls are supported

if __name__ == '__main__':

	if(len(sys.argv)==1):
	#if called directly, jump to main
		main()
	#else, help!
	else:
		help()

else:
	#Not Supported. Work on it.
	print("Module import not supported yet!")
	#So, exiting
	sys.exit(0)
