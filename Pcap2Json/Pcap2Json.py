#!/usr/bin/env python
# Allow shell invocation

# * Marcus Botacin - Unicamp - 2017
# * Protocol Dissector for malware analysis
# * Pcap2Json reads a PCAP and produces a parsed JSON
# * Currently supports: TCP, UDP, HTTP, and DNS

# Import Block

import sys      # args
import getopt   # --parameters
import json	# output utility
import logging	# log lib - disable scapy warning

# disable scapy warnings
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)

from scapy.all import *	# parse net	- read pcap
import scapy_http.http	# parse http	- special headers for http

# Network Functions

# Parse HTTP headers

def parse_http(pkt):
    http_layer = pkt.getlayer(scapy_http.http.HTTPRequest)
    ip_layer = pkt.getlayer(IP)
    method=http_layer.fields['Method']
    host=http_layer.fields['Host']
    path=http_layer.fields['Path']
    entry={'Protocol' : "HTTP", 'IPsrc' : pkt[IP].src, 'PortSRC' :
            pkt[TCP].sport , 'IPdst' : pkt[IP].dst, 'PortDST' : pkt[TCP].dport,
            'Method' : method, 'Host' : host, 'Path' : path}
    return entry

# Get TPC basic info

def parse_tcp(pkt):
    entry={'Protocol' : "TCP", 'IPsrc' : pkt[IP].src, 'PortSRC' :
            pkt[TCP].sport , 'IPdst' : pkt[IP].dst, 'PortDST' : pkt[TCP].dport}
    return entry

# Parse DNS query

def parse_dns_query(pkt):
    query=pkt.getlayer(DNSQR)
    entry={'Protocol' : "DNS", 'IPsrc' : pkt[IP].src, 'PortSRC' :
            pkt[UDP].sport , 'IPdst' : pkt[IP].dst, 'PortDST' : pkt[UDP].dport,
            'Type' : "QUERY", 'Name' : query.qname}
    return entry

# Parse DNS response

def parse_dns_response(pkt):
    answ=[]
    resp=pkt.getlayer(DNSRR)
    a_count = pkt[DNS].ancount
    i = a_count + 4
    if(i<=4):
        answ=["No Answer"]
    else:
        while i > 4:
            answ.append(pkt[i].rdata)
            i -= 1
    entry={'Protocol' : "DNS", 'IPsrc' : pkt[IP].src, 'PortSRC' :
            pkt[UDP].sport , 'IPdst' : pkt[IP].dst, 'PortDST' : pkt[UDP].dport,
            'Type' : "RESPONSE", 'Name' : resp.rrname, 'Answer' : answ}

    return entry

# Verify if DNS entry is a query or a answer
# And parse it properly

def parse_dns(pkt):
    dns_list=[]
    if(DNSQR in pkt):
        qres=parse_dns_query(pkt)
        if(len(qres)!=0):
            dns_list.append(qres)
    if(DNSRR in pkt):
        rres=parse_dns_response(pkt)
        if(len(rres)!=0):
            dns_list.append(rres)
    return dns_list

# If UDP packet

def parse_udp(pkt):
    entry={'Protocol' : "UDP", 'IPsrc' : pkt[IP].src, 'PortSRC' :
            pkt[UDP].sport , 'IPdst' : pkt[IP].dst, 'PortDST' : pkt[UDP].dport}
    return entry
    
# PCAP parser itsel
# Iterate over all packets and process each one

def network_parse(pcap_file):
    
    # no prior data
    tcp_list=[]
    udp_list=[]
    dns_list=[]
    http_list=[]

    # Reading Pcap
    cap=rdpcap(pcap_file)

    # Iterating over each packet
    for pkt in cap:

        # case TCP
    	if TCP in pkt:
                # parse the TCP layer
		tcp_entry=parse_tcp(pkt)
       		if(len(tcp_entry)!=0):
            		tcp_list.append(tcp_entry)

                # TCP carries HTTP
                # parse when present
       		if(pkt.haslayer(scapy_http.http.HTTPRequest)):
		        http_entry=parse_http(pkt)
		        if(len(http_entry)!=0):
        			http_list.append(http_entry)

        # case UDP
        if UDP in pkt:
                # parse UDP layer
        	udp_entry=parse_udp(pkt)
            	if(len(udp_entry)!=0):
                	udp_list.append(udp_entry)

                # UDP carries DNS, parse when present
		if DNS in pkt:
		        dns_entry=parse_dns(pkt)
		        if(len(dns_entry)!=0):
                		dns_list.append({'entry' : dns_entry})

    # assembling the final result
    final={'TCP' : tcp_list, 'UDP' : udp_list, 'DNS' : dns_list, 'HTTP' : http_list}
    return final

# Usage

def usage(bin):
    # Usage info
    print("python "+bin+" -i (--input) <input> -o (--output) <output>")
    # incorrect args, finishing
    sys.exit(0)

# Parser

def parser(args):
    # starts with no input
    input="" 
    output=""
    # zero args check
    if(len(args)>1):
        # having some args
        try:
            # try to get args
            options, remainder = getopt.getopt(sys.argv[1:],"i:o:",["input=","output="])
            # for each retrieved arg
            for opt, args in options:
                # case input
                if opt in ["-i","--input"]:
                    input=args
                # case output
                if opt in ["-o","--output"]:
                    output=args
            # if both were supplied, return
            if(input!="" and output!=""):
                return input,output
            else:
            # if only one, error
                usage(args[0])
        except getopt.GetoptError as err:
            # get opt parsing error
            print(str(err))
            usage(args[0])
    else:
        # case no args supplied
        usage(args[0])

# Main

def main(input,output):
    # debug info
    print("Parsing: %s and storing into: %s" % (input,output))
    # call the parser and dump the result
    out_json=json.dumps(network_parse(input),indent=1)
    # store result
    f=open(output,"w").write(out_json)
    
# Entry Point

# Check who is calling
# By now, only direct calls are supported

if __name__ == '__main__':

	# start parsing args
        input,output=parser(sys.argv)

        # if ok, call main
        main(input,output)

else:
	# Not Supported. Working on it.
	print("Module import not supported yet!")
	#So, exiting
	sys.exit(0)
